
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async screenCapture() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("screen_capture") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async findFidePlayer(player: string) : Promise<Result<FidePlayer | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("find_fide_player", { player }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchFideProfileHtml(fideId: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_fide_profile_html", { fideId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save a FIDE profile photo (either from URL or base64 data) to local storage
 * Returns the local file path
 */
async saveFidePhoto(fideId: string, photoData: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_fide_photo", { fideId, photoData }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get best moves from the engine for a given position and options.
 */
async getBestMoves(id: string, engine: string, tab: string, goMode: GoMode, options: EngineOptions) : Promise<Result<[number, BestMoves[]] | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_best_moves", { id, engine, tab, goMode, options }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Analyze a game using the engine, returning move-by-move analysis.
 */
async analyzeGame(id: string, engine: string, goMode: GoMode, options: AnalysisOptions, uciOptions: EngineOption[]) : Promise<Result<MoveAnalysis[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analyze_game", { id, engine, goMode, options, uciOptions }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop a specific engine process (without killing it) by engine name and tab.
 */
async stopEngine(engine: string, tab: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_engine", { engine, tab }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Kill a specific engine process by engine name and tab.
 * FIXED: Always remove from map to prevent memory leaks
 */
async killEngine(engine: string, tab: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("kill_engine", { engine, tab }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Kill all engine processes associated with a given tab.
 * FIXED: Proper error handling to prevent zombie processes
 */
async killEngines(tab: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("kill_engines", { tab }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Retrieve logs for a specific engine process.
 */
async getEngineLogs(engine: string, tab: string) : Promise<Result<EngineLog[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_engine_logs", { engine, tab }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async memorySize() : Promise<bigint> {
    return await TAURI_INVOKE("memory_size");
},
/**
 * Gets a random puzzle from the database within the specified rating range
 * 
 * This function uses a cache to avoid repeated database queries. The cache is
 * refreshed when it's empty, when the rating range changes, or when all puzzles
 * in the cache have been used.
 * 
 * # Arguments
 * * `file` - Path to the puzzle database
 * * `min_rating` - Minimum puzzle rating to include
 * * `max_rating` - Maximum puzzle rating to include
 * * `random` - Randomize puzzle in cache
 * * `themes` - Optional list of themes to filter by (puzzle must contain at least one)
 * * `opening_tags` - Optional list of opening tags to filter by (puzzle must contain at least one)
 * 
 * # Returns
 * * `Ok(Puzzle)` if a puzzle was found
 * * `Err(Error::NoPuzzles)` if no puzzles match the criteria
 * * Other errors if there was a problem accessing the database
 */
async getPuzzle(file: string, minRating: number, maxRating: number, random: boolean, themes: string[] | null, openingTags: string[] | null) : Promise<Result<Puzzle, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_puzzle", { file, minRating, maxRating, random, themes, openingTags }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async searchOpeningName(query: string) : Promise<Result<OutOpening[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_opening_name", { query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getOpeningFromFen(fen: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_opening_from_fen", { fen }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getOpeningFromName(name: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_opening_from_name", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getOpeningInfoFromFen(fen: string) : Promise<Result<OpeningInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_opening_info_from_fen", { fen }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPlayersGameInfo(file: string, id: number) : Promise<Result<PlayerGameInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_players_game_info", { file, id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Query a UCI engine for its configuration (name and options).
 * FIXED: Proper process cleanup with timeout to prevent zombie processes
 */
async getEngineConfig(path: string) : Promise<Result<EngineConfig, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_engine_config", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fileExists(path: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("file_exists", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getFileMetadata(path: string) : Promise<Result<FileMetadata, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_file_metadata", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async mergePlayers(file: string, player1: number, player2: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("merge_players", { file, player1, player2 }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async convertPgn(file: string, dbPath: string, timestamp: number | null, title: string, description: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("convert_pgn", { file, dbPath, timestamp, title, description }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPlayer(file: string, id: number) : Promise<Result<Player | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_player", { file, id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async countPgnGames(file: string) : Promise<Result<number, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("count_pgn_games", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async readGames(file: string, start: number, end: number) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_games", { file, start, end }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async lexPgn(pgn: string) : Promise<Result<Token[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("lex_pgn", { pgn }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isBmi2Compatible() : Promise<boolean> {
    return await TAURI_INVOKE("is_bmi2_compatible");
},
async deleteGame(file: string, n: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_game", { file, n }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteDuplicatedGames(file: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_duplicated_games", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteEmptyGames(file: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_empty_games", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Clear the in-memory game cache to free memory
 * FIXED: Also clear position search cache to prevent unbounded growth
 */
async clearGames() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_games") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setFileAsExecutable(path: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_file_as_executable", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteIndexes(file: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_indexes", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createIndexes(file: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_indexes", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async editDbInfo(file: string, title: string | null, description: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("edit_db_info", { file, title, description }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteDbGame(file: string, gameId: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_db_game", { file, gameId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a database file and cleanup resources
 * FIXED: Force close all connections before deletion to prevent "database is locked"
 */
async deleteDatabase(file: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_database", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async exportToPgn(file: string, destFile: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_to_pgn", { file, destFile }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async exportPositionGamesToPgn(file: string, fen: string, destFile: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_position_games_to_pgn", { file, fen, destFile }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async exportSelectedGamesToPgn(file: string, gameIds: number[], destFile: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("export_selected_games_to_pgn", { file, gameIds, destFile }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async authenticate(username: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("authenticate", { username }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async writeGame(file: string, n: number, pgn: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("write_game", { file, n, pgn }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async downloadFideDb() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_fide_db") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async downloadFile(id: string, url: string, path: string, token: string | null, finalize: boolean | null, totalSize: number | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_file", { id, url, path, token, finalize, totalSize }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTournaments(file: string, query: TournamentQuery) : Promise<Result<QueryResponse<Event[]>, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_tournaments", { file, query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDbInfo(file: string) : Promise<Result<DatabaseInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_db_info", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGames(file: string, query: GameQueryJs) : Promise<Result<QueryResponse<NormalizedGame[]>, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_games", { file, query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGame(file: string, gameId: number) : Promise<Result<NormalizedGame, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_game", { file, gameId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateGame(file: string, gameId: number, update: UpdateGame) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_game", { file, gameId, update }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * ============================================================================
 * Search for chess positions in the database
 * Returns position statistics and matching games
 * ============================================================================
 */
async searchPosition(file: string, query: GameQueryJs, tabId: string) : Promise<Result<[PositionStats[], NormalizedGame[]], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_position", { file, query, tabId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Pre-cache openings from TSV files
 * This function reads all opening TSV files, converts PGN to FEN,
 * searches for each position in the database, and caches the results
 */
async precacheOpenings(databasePath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("precache_openings", { databasePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Download pre-calculated position cache database
 */
async downloadPositionCache() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_position_cache") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPlayers(file: string, query: PlayerQuery) : Promise<Result<QueryResponse<Player[]>, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_players", { file, query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets information about a puzzle database
 * 
 * This function retrieves metadata about a puzzle database, including:
 * - The title (derived from the filename)
 * - The number of puzzles in the database
 * - The size of the database file
 * - The full path to the database file
 * 
 * # Arguments
 * * `file` - Relative path to the puzzle database within the app's data directory
 * * `app` - Tauri app handle used to resolve the full path
 * 
 * # Returns
 * * `Ok(PuzzleDatabaseInfo)` with the database information
 * * `Err(Error)` if there was a problem accessing the database or file
 */
async getPuzzleDbInfo(file: string) : Promise<Result<PuzzleDatabaseInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_puzzle_db_info", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the minimum and maximum rating range from a puzzle database
 * 
 * This function queries the database to find the lowest and highest puzzle ratings.
 * 
 * # Arguments
 * * `file` - Path to the puzzle database
 * 
 * # Returns
 * * `Ok((min_rating, max_rating))` with the rating range
 * * `Err(Error)` if there was a problem accessing the database
 */
async getPuzzleRatingRange(file: string) : Promise<Result<[number, number], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_puzzle_rating_range", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Imports puzzles from a local file into a new puzzle database
 * 
 * This function can handle different types of puzzle files:
 * - PGN files containing puzzles (with FEN positions and solution moves)
 * - Existing puzzle database files (.db, .db3)
 * - Compressed files (.zst)
 * 
 * # Arguments
 * * `source_file` - Path to the source puzzle file
 * * `db_path` - Path where the new puzzle database should be created
 * * `title` - Title for the puzzle database
 * * `description` - Optional description for the puzzle database
 * * `app` - Tauri app handle for progress events
 * 
 * # Returns
 * * `Ok(())` if import was successful
 * * `Err(Error)` if there was a problem importing the file
 */
async importPuzzleFile(sourceFile: string, dbPath: string, title: string, description: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_puzzle_file", { sourceFile, dbPath, title, description }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if a puzzle database has the themes and opening_tags columns
 * 
 * # Arguments
 * * `file` - Path to the puzzle database
 * 
 * # Returns
 * * `Ok((has_themes, has_opening_tags))` indicating which columns exist
 * * `Err(Error)` if there was a problem accessing the database
 */
async checkPuzzleDbColumns(file: string) : Promise<Result<[boolean, boolean], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_puzzle_db_columns", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets distinct values for themes from a puzzle database
 * OPTIMIZED: Uses normalized table if available, otherwise falls back to old method
 * 
 * # Arguments
 * * `file` - Path to the puzzle database
 * 
 * # Returns
 * * `Ok(Vec<ThemeOption>)` with distinct theme values and their friendly names
 * * `Err(Error)` if there was a problem accessing the database
 */
async getPuzzleThemes(file: string) : Promise<Result<ThemeGroup[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_puzzle_themes", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets distinct values for opening_tags from a puzzle database
 * OPTIMIZED: Uses normalized table if available, otherwise falls back to old method
 * 
 * # Arguments
 * * `file` - Path to the puzzle database
 * 
 * # Returns
 * * `Ok(Vec<OpeningTagOption>)` with distinct opening tag values and their friendly names
 * * `Err(Error)` if there was a problem accessing the database
 */
async getPuzzleOpeningTags(file: string) : Promise<Result<OpeningTagOption[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_puzzle_opening_tags", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validates a downloaded puzzle database file
 */
async validatePuzzleDatabase(file: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_puzzle_database", { file }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkPackageManagerAvailable(manager: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_package_manager_available", { manager }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async installPackage(manager: string, packageName: string) : Promise<Result<PackageManagerResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("install_package", { manager, packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkPackageInstalled(manager: string, packageName: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_package_installed", { manager, packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async findExecutablePath(executableName: string) : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("find_executable_path", { executableName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getVariantPosition(fen: string, engine: string) : Promise<Result<VariantPosition | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_variant_position", { fen, engine }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async upsertVariantPosition(fen: string, engine: string, recommendedMove: string, ms: bigint) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("upsert_variant_position", { fen, engine, recommendedMove, ms }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async analysisDbSetAnalyzedGame(gameId: string, analyzedPgn: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analysis_db_set_analyzed_game", { gameId, analyzedPgn }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async analysisDbGetAnalyzedGame(gameId: string) : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analysis_db_get_analyzed_game", { gameId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async analysisDbGetAllAnalyzedGames() : Promise<Result<AnalyzedGameEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analysis_db_get_all_analyzed_games") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async analysisDbSetGameStats(gameId: string, stats: StoredGameStats) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analysis_db_set_game_stats", { gameId, stats }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async analysisDbGetGameStats(gameId: string) : Promise<Result<StoredGameStats | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analysis_db_get_game_stats", { gameId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async analysisDbGetGameStatsBulk(gameIds: string[]) : Promise<Result<GameStatsEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analysis_db_get_game_stats_bulk", { gameIds }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async analysisDbDeleteEntries(gameIds: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analysis_db_delete_entries", { gameIds }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async analysisDbClearAnalyzedPgns() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analysis_db_clear_analyzed_pgns") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async analysisDbGetAnalyzedGamesBulk(gameIds: string[]) : Promise<Result<AnalyzedGameEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("analysis_db_get_analyzed_games_bulk", { gameIds }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openExternalLink(url: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_external_link", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
bestMovesPayload: BestMovesPayload,
databaseProgress: DatabaseProgress,
downloadProgress: DownloadProgress,
reportProgress: ReportProgress
}>({
bestMovesPayload: "best-moves-payload",
databaseProgress: "database-progress",
downloadProgress: "download-progress",
reportProgress: "report-progress"
})

/** user-defined constants **/



/** user-defined types **/

/**
 * Options for full-game analysis (FEN, moves, novelty annotation, etc).
 */
export type AnalysisOptions = { fen: string; moves: string[]; annotateNovelties: boolean; referenceDb: string | null; reversed: boolean }
export type AnalyzedGameEntry = { game_id: string; analyzed_pgn: string }
/**
 * Best-move line from engine output, including PV, score, and stats.
 */
export type BestMoves = { nodes: number; depth: number; score: Score; uciMoves: string[]; sanMoves: string[]; multipv: number; nps: number }
/**
 * Event payload for best-move updates (emitted to frontend).
 */
export type BestMovesPayload = { bestLines: BestMoves[]; engine: string; tab: string; fen: string; moves: string[]; progress: number }
export type DatabaseInfo = { title: string; description: string; player_count: number; event_count: number; game_count: number; storage_size: bigint; filename: string; indexed: boolean }
export type DatabaseProgress = { id: string; progress: number }
export type DownloadProgress = { progress: number; id: string; finished: boolean }
/**
 * UCI engine configuration (name and available options).
 */
export type EngineConfig = { name: string; options: UciOptionConfig[] }
/**
 * Log entry for engine GUI or engine output.
 */
export type EngineLog = { type: "gui"; value: string } | { type: "engine"; value: string }
/**
 * UCI engine option (name-value pair).
 */
export type EngineOption = { name: string; value: string }
/**
 * Options for configuring engine analysis (FEN, moves, extra UCI options).
 */
export type EngineOptions = { fen: string; moves: string[]; extraOptions: EngineOption[] }
export type Event = { id: number; name: string | null }
export type FidePlayer = { fideid: number; name: string; country: string; sex: string; title: string | null; w_title: string | null; o_title: string | null; foa_title: string | null; rating: number | null; games: number | null; k: number | null; rapid_rating: number | null; rapid_games: number | null; rapid_k: number | null; blitz_rating: number | null; blitz_games: number | null; blitz_k: number | null; birthday: number | null; flag: string | null }
export type FileMetadata = { last_modified: bigint; size: bigint; is_dir: boolean; is_readonly: boolean }
export type GameOutcome = "Won" | "Drawn" | "Lost"
export type GameQueryJs = { options?: QueryOptions<GameSort> | null; 
/**
 * Optional limit for number of game details to load (stats are always full)
 * Used to fetch small preview (e.g., 10) and then on-demand up to 1000
 * Using u64 instead of usize for better bigint compatibility with TypeScript
 * Serialized as string to handle bigint in JSON
 */
game_details_limit?: bigint | null; player1?: number | null; player2?: number | null; tournament_id?: number | null; start_date?: string | null; end_date?: string | null; range1?: [number, number] | null; range2?: [number, number] | null; sides?: Sides | null; outcome?: string | null; position?: PositionQueryJs | null; wanted_result?: string | null }
export type GameSort = "id" | "date" | "whiteElo" | "blackElo" | "averageElo" | "ply_count"
export type GameStatsEntry = { gameId: string; accuracy: number; acpl: number; estimatedElo: bigint | null }
/**
 * Engine search mode (depth, time, nodes, etc).
 */
export type GoMode = { t: "PlayersTime"; c: PlayersTime } | { t: "Depth"; c: number } | { t: "Time"; c: number } | { t: "Nodes"; c: number } | { t: "Infinite" }
/**
 * Analysis result for a single move/position.
 */
export type MoveAnalysis = { best: BestMoves[]; novelty: boolean; is_sacrifice: boolean }
export type NormalizedGame = { id: number; fen: string; event: string; event_id: number; site: string; site_id: number; date?: string | null; time?: string | null; round?: string | null; white: string; white_id: number; white_elo?: number | null; black: string; black_id: number; black_elo?: number | null; result: Outcome; time_control?: string | null; eco?: string | null; ply_count?: number | null; moves: string }
export type OpeningInfo = { eco: string; opening: string; variation: string }
/**
 * Opening tag option with technical value and friendly label
 */
export type OpeningTagOption = { value: string; label: string }
export type OutOpening = { name: string; fen: string }
export type Outcome = "1-0" | "0-1" | "1/2-1/2" | "*"
export type PackageManagerResult = { success: boolean; stdout: string; stderr: string }
export type Player = { id: number; name: string | null; elo: number | null }
export type PlayerGameInfo = { site_stats_data: SiteStatsData[] }
export type PlayerQuery = { options: QueryOptions<PlayerSort>; name?: string | null; range?: [number, number] | null }
export type PlayerSort = "id" | "name" | "elo"
/**
 * Player time controls for GoMode::PlayersTime.
 */
export type PlayersTime = { white: number; black: number; winc: number; binc: number }
export type PositionQueryJs = { fen: string; type_: string }
export type PositionStats = { move: string; white: number; draw: number; black: number }
export type Puzzle = { id: number; fen: string; moves: string; rating: number; rating_deviation: number; popularity: number; nb_plays: number; themes: string | null; game_url: string | null; opening_tags: string | null }
/**
 * Information about a puzzle database
 */
export type PuzzleDatabaseInfo = { 
/**
 * The title of the puzzle database (derived from filename)
 */
title: string; 
/**
 * Description of the puzzle database (currently not populated)
 * TODO: Consider adding a way to store and retrieve database descriptions
 */
description: string; 
/**
 * Number of puzzles in the database
 */
puzzleCount: number; 
/**
 * Size of the database file in bytes
 */
storageSize: bigint; 
/**
 * Full path to the database file
 */
path: string }
export type QueryOptions<SortT> = { skipCount: boolean; page?: number | null; pageSize?: number | null; sort: SortT; direction: SortDirection }
export type QueryResponse<T> = { data: T; count: number | null }
/**
 * Event payload for reporting analysis progress.
 */
export type ReportProgress = { progress: number; id: string; finished: boolean }
export type Score = { value: ScoreValue; 
/**
 * The probability of each result (win, draw, loss).
 */
wdl: [number, number, number] | null }
export type ScoreValue = 
/**
 * The score in centipawns.
 */
{ type: "cp"; value: number } | 
/**
 * Mate coming up in this many moves. Negative value means the engine is getting mated.
 */
{ type: "mate"; value: number }
export type Sides = "BlackWhite" | "WhiteBlack" | "Any"
export type SiteStatsData = { site: string; player: string; data: StatsData[] }
export type SortDirection = "asc" | "desc"
export type StatsData = { date: string; is_player_white: boolean; player_elo: number; result: GameOutcome; time_control: string; opening: string }
export type StoredGameStats = { accuracy: number; acpl: number; estimatedElo: bigint | null }
/**
 * Theme group containing a category name and its themes
 */
export type ThemeGroup = { group: string; items: ThemeOption[] }
/**
 * Theme option with technical value and friendly label
 */
export type ThemeOption = { value: string; label: string }
export type Token = { type: "ParenOpen" } | { type: "ParenClose" } | { type: "Comment"; value: string } | { type: "San"; value: string } | { type: "Header"; value: { tag: string; value: string } } | { type: "Nag"; value: string } | { type: "Outcome"; value: string }
export type TournamentQuery = { options: QueryOptions<TournamentSort>; name: string | null }
export type TournamentSort = "id" | "name"
/**
 * Represents a UCI option definition.
 */
export type UciOptionConfig = 
/**
 * The option of type `check` (a boolean).
 */
{ type: "check"; value: { 
/**
 * The name of the option.
 */
name: string; 
/**
 * The default value of this `bool` property.
 */
default: boolean | null } } | 
/**
 * The option of type `spin` (a signed integer).
 */
{ type: "spin"; value: { 
/**
 * The name of the option.
 */
name: string; 
/**
 * The default value of this integer property.
 */
default: bigint | null; 
/**
 * The minimal value of this integer property.
 */
min: bigint | null; 
/**
 * The maximal value of this integer property.
 */
max: bigint | null } } | 
/**
 * The option of type `combo` (a list of strings).
 */
{ type: "combo"; value: { 
/**
 * The name of the option.
 */
name: string; 
/**
 * The default value for this list of strings.
 */
default: string | null; 
/**
 * The list of acceptable strings.
 */
var: string[] } } | 
/**
 * The option of type `button` (an action).
 */
{ type: "button"; value: { 
/**
 * The name of the option.
 */
name: string } } | 
/**
 * The option of type `string` (a string, unsurprisingly).
 */
{ type: "string"; value: { 
/**
 * The name of the option.
 */
name: string; 
/**
 * The default value of this string option.
 */
default: string | null } }
export type UpdateGame = { fen: string; event: string; site: string; date?: string | null; time?: string | null; round?: string | null; white: string; white_elo?: number | null; black: string; black_elo?: number | null; result: Outcome; time_control?: string | null; eco?: string | null; ply_count?: number | null; moves: string }
export type VariantPosition = { fen: string; engine: string; recommended_move: string; ms: bigint }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
